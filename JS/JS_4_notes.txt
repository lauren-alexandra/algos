Execution Contexts

manage the complexity of interpreting and running code
Contexts get placed on the execution stack


This keyword
Allows use to reuse functions with different contexts 
Note: if this keyword is not bound, it will default to window
Implicit Binding
Left of the . dot at call time to see what the this keyword references
person.sayHello(); 
Explicit Binding
Call, apply, bind

E.g. Call a function in the context of a given object 

Function sayHello() {
	console.log(“Hello, “ + this.name);
}

Var bob= {
	Name: ‘Bob’,
	Age: 20
}

sayHello.call(bob); // the this keyword in sayHello() func will reference bob

E.g. Apply 

Var languages = [l1, l2, l3]; 
sayHello.apply(bob, languages);  // allows you to pass in an array of arguments.


E.g. Bind
// is the same as call but instead of immediately invoking the function it will return a new 
// function that you can invoke later

Var newFunc = sayHello.bind(bob, l1, l2, l3);  	// also like Call can pass in arguments 



Async JavaScript - Callbacks, Promises, Async/Await

Callbacks: 
When you have a function that accepts another function as an argument, the 
function is a higher order function and the argument is a callback. 

e.g. 
function myHigherOrderFunc(callback) {
	return callback(); 
} 

or 

[1, 2, 3].map((i) => i + 5) // with map being the higher order function and the 
anonymous function being the callback. 


Promises:
// The promise object takes a callback as an arugment 
// When resolve() invoked, status of promise becomes fulfilled
// When reject() invoked, status of promise becomes rejected

e.g.
const promise = new Promise((resolve, reject) => {
	setTimeout(() => { 
		resolve()
	}, 2000) 
}); 

function onSuccess() {
	console.log('Success');
}

function onError() {
	console.log('Error');
}

promise.then(onSuccess); 	// this should be called
promise.catch(onError); 	// if the promise instead invoked reject(), this would log


Async/Await:
// the benefit? we can write asynchronous code as if it were synchronous

$('#myButton').on('click', async () => {
	const userData = await getUserData('jill')

	updateUI(userData); 
}); 



Prototypes

A prototype is a property that every function in JavaScript except arrow functions have that points to an object.

E.g.

Function Animal(name) {
	Let animal = Object.create(Animal.prototype); 
	Animal.name = name; 
	Return animal; 
} 

Animal.prototype.sleep = function () {
	console.log(‘${this.name} is going to sleep.’);
} 

Const lion = Animal(‘Jack’);
lion.sleep(); 
// Jack is going to sleep. 


If you were to use the new keyword like:

Const tiger = new Animal(‘Jill’); 

Then behind the scenes JavaScript would be doing this:

Function Animal(name) {
	Let this = Object.create(Animal.prototype); // behind the scenes
	This.name = name;
	Return this; // behind the scenes
} 


Above is a version of a class without syntactic sugar. You can do an ES6 class like this:

Class Animal {
	constructor(name) {
		This.name = name;
	}
	sleep() {
		console.log(‘${this.name} is going to sleep.’);
	}
} 

Const bear = new Animal(‘Joe’); 

Arrow functions don’t have their own this keyword. Thus arrow functions can’t be constructor functions. Essentially, it can’t create this: 
Let this = Object.create(MyClassName.prototype); // behind the scenes 

So arrow functions don’t have a prototype property. 



Inheritance and the Prototype Chain

function Animal (name, energy) {
  this.name = name
  this.energy = energy
}

Bind the this context with .call() 

.call is a method on every function that allows you to invoke the function specifying in what context the function will be invoked.

e.g. 

function Dog (name, energy, breed) {
  Animal.call(this, name, energy)

  this.breed = breed
}

const charlie = new Dog('Charlie', 10, 'Goldendoodle')

charlie.name // Charlie
charlie.energy // 10
charlie.breed // Goldendoodle

OR

function Animal (name, energy) {
  this.name = name
  this.energy = energy
}

function Dog (name, energy, breed) {
  Animal.call(this, name, energy)

  this.breed = breed
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
	this.energy = 1;
	console.log(‘Woof!’); 
} 

Const bailey = new Dog(5); 

bailey.bark();
// Woof! 


NOTE: when creating an ES6 class, calling super() calling the constructor of the base
class like this: 
Animal.call(this, name, energy)










