Types

Most of the values in JavaScript can behave
like an object but that does not make them objects.
This is not true: "everything is an object."

Primitive Types
- undefined
- string
- number
- boolean
- object 
- symbol (es6). used to create pseudo-private keys on objects.
Symbol(); 

Variables do not have types. Values do.

typeof null // returns "object" 
// this is a historical bug in JS. should return "null"


Emptiness 
undefined vs undeclared vs uninitialized (temporal dead zone - TDZ)

TDZ
Certain variables like block scope ones never get initialized as undefined.

Undefined
Variable has been initialized but not defined.

Undeclared
Variable has never been created. 

Special Values:
NaN and isNan

NaN "not a number" 
Means value is an invalid number.

In JS,
NaN !== NaN

NaN does not have the identity property, i.e. it is not equal to itself.
So, you need to use Number.isNaN() to check.

instead of 

var myAge = Number("age"); // NaN 
myAge === NaN // this will return false 

so use

Number.isNaN(myAge) // true 


Negative Zero (-0)

In JS, -0 is valid. It also does weird stuff.

To check for it:

var myNegZero = -0;
Object.is(myNegZero, -0); // true 


Fundamental Objects (Built-In Objects)

Use the new keyword for these: 

Object()
Array()
Function()
Date()		// e.g. new Date(); 
RegExp()
Error() 

Do not use the new keyword for these:

String()	// e.g. String(myVariable) 
Number()
Boolean()


Coercion 

Abstract Operations
They are the fundamental building block of how we deal with type conversion ("coercion").

ToPrimitive(hint)  
// takes a function, array, etc. and turns into primitive value
// accepts a "type hint" where you tell the func what type you would like the value to be converted to
// whatever value you provide will be run through one or both functions:
valueOf() and toString()


ToString()
// takes any value and gives the representation of that value in String form

ToNumber()
// takes a value, returns a number. e.g. 
ToNumber("") // 0 

ToBoolean() 
// is the value falsy or truthy? 
Falsy
"" 
0, -0
null
NaN
false
undefined

Everything else is "truthy", will return true.


Coercion

A quality JS program embraces coercions AND makes sure the types involved in every operation are clear.
This effort can be aided by typed libraries like Typescript

JavaScript's dynamic typing is not a weakness, it's one of its strong qualities.


Equality
== vs. ===

=== if the types are different, there is no way the two values can be equal.
Disallows coercion

== 
Allows coercion if types different 
Only compares primitive values. If values are not primitive, ToPrimitive() is called.
If the values are primitive, the double equals algorithm prefers to use ToNumber(). 


The case for preferring double equals ==
 
Knowing types is always better than not knowing them
Static Types is not the only (or even necessarily best) way to know your types 
-->Only use == when comparing known types.
Why: If you know the types in a comparison: If the types are different, the equivalent
of one == would be two (or more!) === (ie, "slower") 

Note: not knowing the types means not fully understaind that code.
So best to refactor so you can know the types.

The usage of === should be reserved for when you do not know the types.


Scope

JavaScript is parsed/processed before line by line execution occurs. 



Closures are frequently used in JavaScript for:
object data privacy, in event handlers and callback functions,
and in partial applications, currying, and other functional
programming patterns.

Why understand closures?
Understanding how variables and functions relate to each other is 
critical to understanding what's going on in your code, in both
functional and object oriented programming styles.

Closures are important because they control what is and isn't in scope
in a particular function, along with which variables are shared between
sibling functions in the same containing scope. 

With closures, the inner function will have access to the variables in the outer function
scope, even after the outer function has returned.






























