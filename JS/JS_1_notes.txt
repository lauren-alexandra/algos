Types and Coercion

FALSE: Everything in JavaScript is an object.


There are primitive types (types that are not collections of values)
Undefined
String
Number
Boolean
Object 
Null
Symbol - not used that often. Var x = Symbol();

Subtypes of the Object type
Function
Array


Variables don’t have types, values do.

Var v; 
// this is undefined. Value not defined 

NaN
// not a number value 

When to use the new keyword for fundamental objects:

Do (
e.g. 
new Object();
new Date(“March 6, 2020”); 
)

Object()
Array()
Function()
Date()
RegExp()
Error()

Don’t
E.g. (
Var myNum = 2;
String(myNum);
// “2” 

String()
Number()
Boolean() 

---
Coercion 
// in a dynamically typed language like JS we can convert types with coercion

E.g. string concatenation
Number to string 

Booleans - Falsy and Truthy

Falsy
“”
0
-0
Null
NaN
False
undefined

Truthy 
“Foo”
23
{a:1}
[1,3]
True
function(){}

Coercion with operators

If comparing a string to a number, the string will be converted to number
myVar > 2 // numeric comparison. This is implicit coercion
Number(myVar) > 2 // this is explicit coercion 

What == vs. === in JS really means:
Coercive equality vs. Non-coercive equality
==	allows coercion. Types different
=== 	does not allow coercion. Types same 

Function expressions:
Is a function that is assigned as a value.
Functions are first-class citizens which mean they can be passed as values.
A programming language is said to have First-class functions when functions in that language are treated like any other variable.
Anonymous function expression is a func exp w/o a name
Named function expression e.g. function myNamedFunc() {}

IIFE “iffy” Immediately Invoked Function Expression

Wrapped in () 

Var greet = ‘hello’; 

( function myFunc() {
	Var greet = ‘hi’; 
	Return greet; 
})(); 

There is a block of scope inside myFunc() 

Instead of using IIFE, can use block scope with let.

Var greet = ‘hello’;

{ 
	Let greet = ‘hi’;
	console.log(greet);
} 

When to use let keyword: 
Just use it for block scope. Anytime you see { … } 
For function scope use const unless there is use case for var. 


Closure
Is when a function “remembers” the variables outside of it, even if you pass that function elsewhere. 

Function myFunc(apple) {
	anotherFunc() {			// anotherFunc has closure over apple variable 
		console.log(apple);
	}
} 

---
This keyword

A function’s this references the execution context for that call, determined entirely by how the function was called. 

This produces a dynamic context. A func can have a dif context each time its called making it more flexible and reusable.

E.g.

Var workshop = {
	Teacher: ‘john’,
	ask(question) {
		console.log(this.teacher, question);
	}
};

workshop.ask(‘Who is the teacher?’); 	
// workshop.ask() is an implicit binding of the this keyword

Prototypes
Prototypes are the mechanism by which JavaScript objects inherit features from one another.

Function Workshop(teacher) {
	This.teacher = teacher;		// constructor for new Workshop objects
} 
Workshop.prototype.ask = function(question) {
	console.log(this.teacher, question)		// 
};
Var deepJS = new Workshop(‘john’);
deepJS.ask(‘what is a prototype?’); 		
// has implicit this binding 
// when we call deepJS.ask(), deepJS will delegate up the prototype chain up to Workshop.prototype

---
class {} 		// es6
ES6 Classes formalize the common JavaScript pattern of simulating class-like inheritance hierarchies using functions and prototypes.
The class function basically creates a template that we can use to create objects later.

class Workshop {
	constructor(teacher) {
		this.teacher = teacher;
	}
	ask(question) {
		console.log(this.teacher, question);
	}
}
Var deepJS = new Workshop(‘john’);
deepJS.ask(‘what is a class?’); 	








