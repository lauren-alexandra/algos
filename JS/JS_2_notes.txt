JS fundamentals to functional

Functional programming is a programming style and about verbs
Includes pure functions without side effects. Makes code easier to test and trust.
They can’t affect any other data outside the scope of that function



Object oriented programming is about nouns

Primitive values get passed by value, e.g. string , number, boolean
Non-primitive values get passed by reference, e.g. arrays, objects, functions. It’s important that you don’t mutate your data (unintentionally by modifying the referenced/pointed at value). It is recommended to make copies of your data. 

Objects

Var person = {};		// object literal notation
Person.name = ‘mrs.white’;
Var person = {
	“Name”: “mrs.white”
};

Arrays

Because arrays are objects they can have properties like length and more that are accessed by dot notation.

E.g. perfectly legal to do this

Var person = [];

Person.name = ‘Mrs. White’;

// legal to do this too

Var person = [];

Var plea = “would”;

Person[plea] = “i would”;

// this creates a property “would” with a value “i would”
“Would”: “i would” 	on the person array which is an object.


OR just do this
Person[“plea”] = “i would” 


ES6 Destructuring 
Is a simplified way of defining variables and assigning values from an object or array.

Source 		Target
Const [first, second] = [true, false]

Assignment
[first, second] = [true, false]


Const: can’t reassign to new value

E.g.

Const j = { x: 1 };
J = {}; // won’t work

J.y = 2;
// j = { x: 1, y: 2}; 	will work

E.g.

{first, second} = {first: 0, second: 1}		// the names have to match. First to first , etc 
console.log(first);
// 0 

Omit certain values
Var [a, , b] = [1, 2, 3]
console.log(a, b)
// 1 3 

// Rest syntax looks exactly like spread syntax, but is used for destructuring arrays and objects. In a way, rest syntax is the opposite of spread syntax. Spread syntax "expands" an array into its elements, while rest syntax collects multiple elements and "condenses" them into a single element.
Combine with rest operator (accumulates rest of the values).

Var [a, ...b] = [1, 2, 3]
console.log(a, b)
// 1 [2, 3]

Swap variables easily without temp.
[b, a] = [a, b]

Destructure with objects
Var { user: x } = { user: 5 };
console.log(x)
=> 5


List Transformations - Nested Data Structures

forEach() calls a provided callback function once for each element in an array in ascending order.
[‘a’, ‘b’, ‘c’].forEach(function(value, index, list){ … }); 
callback is invoked with three arguments:
the value of the element
the index of the element
the Array object being traversed

items.forEach(function(item){ copyItems.push(item) })

.map() function
Produces a new array of values by mapping each value in list through a transformation function (iterator)
Each invocation of iterator is called with three arguments: (element, index, list). If list is a JavaScript object, iterator’s arguments will be (value, key, list) 

let numbers = [1, 4, 9] let roots = numbers.map(function(num) { return Math.sqrt(num) }) // roots is now [1, 2, 3] // numbers is still [1, 4, 9]


