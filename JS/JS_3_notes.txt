Types

Most of the values in JavaScript can behave
like an object but that does not make them objects.
This is not true: "everything is an object."

Primitive Types
- undefined
- string
- number
- boolean
- object 
- symbol (es6). used to create pseudo-private keys on objects.
Symbol(); 

Variables do not have types. Values do.

typeof null // returns "object" 
// this is a historical bug in JS. should return "null"


Emptiness 
undefined vs undeclared vs uninitialized (temporal dead zone - TDZ)

TDZ
Certain variables like block scope ones never get initialized as undefined.

Undefined
Variable has been initialized but not defined.

Undeclared
Variable has never been created. 

Special Values:
NaN and isNan

NaN "not a number" 
Means value is an invalid number.

In JS,
NaN !== NaN

NaN does not have the identity property, i.e. it is not equal to itself.
So, you need to use Number.isNaN() to check.

instead of 

var myAge = Number("age"); // NaN 
myAge === NaN // this will return false 

so use

Number.isNaN(myAge) // true 


Negative Zero (-0)

In JS, -0 is valid. It also does weird stuff.

To check for it:

var myNegZero = -0;
Object.is(myNegZero, -0); // true 


Fundamental Objects (Built-In Objects)

Use the new keyword for these: 

Object()
Array()
Function()
Date()		// e.g. new Date(); 
RegExp()
Error() 

Do not use the new keyword for these:

String()	// e.g. String(myVariable) 
Number()
Boolean()


Coercion 

Abstract Operations
They are the fundamental building block of how we deal with type conversion ("coercion").

ToPrimitive(hint)  
// takes a function, array, etc. and turns into primitive value
// accepts a "type hint" where you tell the func what type you would like the value to be converted to
// whatever value you provide will be run through one or both functions:
valueOf() and toString()


ToString()
// takes any value and gives the representation of that value in String form

ToNumber()
// takes a value, returns a number. e.g. 
ToNumber("") // 0 

ToBoolean() 
// is the value falsy or truthy? 
Falsy
"" 
0, -0
null
NaN
false
undefined

Everything else is "truthy", will return true.


Coercion

A quality JS program embraces coercions AND makes sure the types involved in every operation are clear.
This effort can be aided by typed libraries like Typescript

JavaScript's dynamic typing is not a weakness, it's one of its strong qualities.


Equality
== vs. ===

=== if the types are different, there is no way the two values can be equal.
Disallows coercion

== 
Allows coercion if types different 
Only compares primitive values. If values are not primitive, ToPrimitive() is called.
If the values are primitive, the double equals algorithm prefers to use ToNumber(). 


The case for preferring double equals ==
 
Knowing types is always better than not knowing them
Static Types is not the only (or even necessarily best) way to know your types 
-->Only use == when comparing known types.
Why: If you know the types in a comparison: If the types are different, the equivalent
of one == would be two (or more!) === (ie, "slower") 

Note: not knowing the types means not fully understaind that code.
So best to refactor so you can know the types.

The usage of === should be reserved for when you do not know the types.


Closures are frequently used in JavaScript for:
object data privacy, in event handlers and callback functions,
and in partial applications, currying, and other functional
programming patterns.

Why understand closures?
Understanding how variables and functions relate to each other is 
critical to understanding what's going on in your code, in both
functional and object oriented programming styles.

Closures are important because they control what is and isn't in scope
in a particular function, along with which variables are shared between
sibling functions in the same containing scope. 

With closures, the inner function will have access to the variables in the outer function
scope, even after the outer function has returned.


Pure functions

A pure function is a function which given the same input, will always produce the same output. 
It produces no side effects.

Pure functions are essential for a variety of purposes, including functional programming,
reliable concurrency, and React+Redux apps. Note: reducers must be pure functions.

If a function were to mutate a property on an object or array parameter that would mutate state
that is accessible outside the function. Pure functions must not mutate external state.

When passing an object to an array to a function, you are passing a reference. You don't
want to mutate the original object or array. Instead, make a copy of the argument. 
e.g. 
const newObject = (value) => Object.assign({}, value); 

Redux

Redux lets you compose reducers rather than deal with the entire app state inside each reducer.

Why compose reducers? You don't have to create a deep clone of the entire app state every time you
want to update just a small part of it. Instead, you can use non-destructive array methods, or 
`Object.assign()` to update a small part of the app state. 

Misc - Functions

Function procedures: 
A function may be called to perform a sequence of steps. The sequence is
known as a procedure, and programming in this style is known as procedural programming. 

Function I/O:
Some functions exist to communicate with other parts of the system, such as the screen, storage,
system logs, or network. 

Program determinism: 
A deterministic algorithm is an algorithm which, given a particular input, will always produce the same
output, with the underlying machine always passing through the same sequence of states. 

Single threaded JS:
A single threaded JS engine does not imply that there is no concurrency. On the contrary, there are many
sources of concurrency in JavaScript. API I/O, event listeners, web workers, iframes, and timeouts can all
introduce indeterminism into your program. 

Concurrency: 
When two tasks can start, run, and complete in overlapping time periods. 

Parallelism:
When tasks literally run at the same time, e.g. on a multi-core processor.  

What is a Promise?

A promise is an object that may produce a single value some time in the future. The value is a resolved value or a reason why it’s not resolved e.g. what error occurred. 

A promise may be in one of three states:
Fulfilled, pending, rejected.

Promise uses can attach callbacks to handle the fulfilled value or the reason for rejection. 

A promise is an object which can be returned synchronously from an asynchronous function.
A promise will be in one of 3 possible states:
Fulfilled: onFulfilled() will be called (e.g., resolve() was called)
Rejected: onRejected() will be called (e.g., reject() was called)
Pending: not yet fulfilled or rejected

A promise is not settled if it’s pending. Once a promise is settled, it can not be resettled.

The ES6 promise constructor takes a function. That function takes two parameters, resolve(), and reject().

You can optionally resolve() or reject() with values, which will be passed to the callback functions attached with .then().
When I reject() with a value, I always pass an Error object. Generally I want two possible resolution states: the normal happy path, or an exception — anything that stops the normal happy path from happening. Passing an Error object makes that explicit.
Promises following the spec must follow a specific set of rules:
A promise or “thenable” is an object that supplies a standard-compliant .then() method.
A pending promise may transition into a fulfilled or rejected state.
A fulfilled or rejected promise is settled, and must not transition into any other state.
Once a promise is settled, it must have a value (which may be undefined). That value must not change.

Every promise must supply a .then() method with the following signature:
promise.then(
 onFulfilled?: Function,
 onRejected?: Function
) => Promise

.then() must return a new promise, promise2

Because .then() always returns a new promise, it’s possible to chain promises with precise control over how and where errors are handled. Promises allow you to mimic normal synchronous code’s try/catch behavior.


Promise Error Handling Example

save()
 .then(handleSuccess)
 .catch(handleError)
;


I recommend ending all promise chains with a .catch().

Promise.race() takes an array (or any iterable) and returns a promise that resolves with the value of the first resolved promise in the iterable, or rejects with the reason of the first promise that rejects.
Promise.all() takes an array (or any iterable) and returns a promise that resolves when all of the promises in the iterable argument have resolved, or rejects with the reason of the first passed promise that rejects.


Functional Programming

Functional programming (often abbreviated FP) is the process of building software by composing pure functions, avoiding shared state, mutable data, and side-effects. 

Functional programming is declarative rather than imperative

Application state flows through pure functions. 

Functional programming is a programming paradigm, meaning that it is a way of thinking about software construction based on some fundamental, defining principles.

Functional code tends to be more concise, more predictable, and easier to test than imperative or object oriented code.

A pure function is a function which:
Given the same inputs, always returns the same output, and
Has no side-effects
Function composition is the process of combining two or more functions in order to produce a new function or perform some computation. 


For example, the composition f . g (the dot means “composed with”) is equivalent to f(g(x)) in JavaScript.

Shared state is any variable, object, or memory space that exists in a shared scope, or as the property of an object being passed between scopes. 

A shared scope can include global scope or closure scopes.

Shared state common problems:
Race conditions
changing the order in which functions are called can cause a cascade of failures because functions which act on shared state are timing dependent


Scope

scope: is the region of a computer program where the binding is valid: where the name can be used to refer to the entity.

Lexical scope: Lexical scope means that in a nested group of functions, the inner functions have access to the variables and other 
resources of their parent scope. This means that the child functions are lexically bound to the execution context of their parents. 

Closure is when a function “remembers” its lexical scope even when the function is executed outside that lexical scope.

JavaScript is parsed/processed BEFORE line by line execution occurs. 

Note: if a variable is referenced within some local scope outside in the 
global scope AND that variable has not been formally declared, instead of 
an error being thrown, the JS interpreter will create a variable declaration
in the GLOBAL scope 
HOWEVER:
if you are using a transpiler like Babel, the interpretation is in strict mode
and if we attempted the case above, we would get a ReferenceError.


undefined vs. undeclared:

undefined: a variable exists but has no value. 

undeclared: a variable is never formally declared
in any scope we have access to.


Modules encapsulate data and behavior (methods) together. The state (data) of a module is held by its methods via closure.


this keyword

A function's this references the execution context for that call, determined entirely by how the function was called.


Binding

implicit binding:

var workshop = { 
	teacher: 'bob',
	ask(question) {
		console.log(this.teacher, question);
	}
};

workshop.ask('what is implicit binding?'); 


dynamic binding:

function ask(question) {
	console.log(this.teacher, question);
}

var workshop1 = {
	teacher: 'bob',
	ask: ask
};

workshop1.ask('how do i share a method?'); 


explicit binding:

function ask(question) {
	console.log(this.teacher, question);
}

var workshop1 = {
	teacher: 'bob'
}; 

ask.call(workshop1, 'can i explicitly set context?'); 


hard binding:

var workshop = {
	teacher: 'bob',
	ask(question) {
		console.log(this.teacher, question);
	}
};

setTimeout(workshop.ask.bind(workshop), 10, 'hard bound this?'); 


this and arrow functions:
An arrow function doesn't define a this, so it's like any normal
variable, and resolves lexically (aka "lexical this")


let and var
- use var to declare at the top of the function. to signal to
be used throughout the function. 
- use let inside a for loop or block scope. why? semantics.
signal to the reader variable is for block scope. 

Block Scope. A block scope is the area within if, switch 
conditions or for and while loops. Generally speaking, 
whenever you see {curly brackets}, it is a block. In ES6, 
const and let keywords allow developers to declare variables 
in the block scope, which means those variables exist only 
within the corresponding block.


const: use when you know you won't reassign a value.


Hoisting:
Hoisting is the JavaScript interpreter’s action of moving all 
variable and function declarations to the top of the current 
scope. However, only the actual declarations are hoisted. Any 
assignments are left where they are.

Note: can write your executable code first and any declared 
functions can be written at the bottom of a page and hoisted. 





