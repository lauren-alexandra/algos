Types

Most of the values in JavaScript can behave
like an object but that does not make them objects.
This is not true: "everything is an object."

Primitive Types
- undefined
- string
- number
- boolean
- object 
- symbol (es6). used to create pseudo-private keys on objects.
Symbol(); 

Variables do not have types. Values do.

typeof null // returns "object" 
// this is a historical bug in JS. should return "null"


Emptiness 
undefined vs undeclared vs uninitialized (temporal dead zone - TDZ)

TDZ
Certain variables like block scope ones never get initialized as undefined.

Undefined
Variable has been initialized but not defined.

Undeclared
Variable has never been created. 

Special Values:
NaN and isNan

NaN "not a number" 
Means value is an invalid number.

In JS,
NaN !== NaN

NaN does not have the identity property, i.e. it is not equal to itself.
So, you need to use Number.isNaN() to check.

instead of 

var myAge = Number("age"); // NaN 
myAge === NaN // this will return false 

so use

Number.isNaN(myAge) // true 


Negative Zero (-0)

In JS, -0 is valid. It also does weird stuff.

To check for it:

var myNegZero = -0;
Object.is(myNegZero, -0); // true 


Fundamental Objects (Built-In Objects)

Use the new keyword for these: 

Object()
Array()
Function()
Date()		// e.g. new Date(); 
RegExp()
Error() 

Do not use the new keyword for these:

String()	// e.g. String(myVariable) 
Number()
Boolean()


Coercion 

Abstract Operations
They are the fundamental building block of how we deal with type conversion ("coercion").

ToPrimitive(hint)  
// takes a function, array, etc. and turns into primitive value
// accepts a "type hint" where you tell the func what type you would like the value to be converted to
// whatever value you provide will be run through one or both functions:
valueOf() and toString()


ToString()
// takes any value and gives the representation of that value in String form

ToNumber()
// takes a value, returns a number. e.g. 
ToNumber("") // 0 

ToBoolean() 
// is the value falsy or truthy? 
Falsy
"" 
0, -0
null
NaN
false
undefined

Everything else is "truthy", will return true.


Coercion

A quality JS program embraces coercions AND makes sure the types involved in every operation are clear.
This effort can be aided by typed libraries like Typescript

JavaScript's dynamic typing is not a weakness, it's one of its strong qualities.


Equality
== vs. ===

=== if the types are different, there is no way the two values can be equal.
Disallows coercion

== 
Allows coercion if types different 
Only compares primitive values. If values are not primitive, ToPrimitive() is called.
If the values are primitive, the double equals algorithm prefers to use ToNumber(). 


The case for preferring double equals ==
 
Knowing types is always better than not knowing them
Static Types is not the only (or even necessarily best) way to know your types 
-->Only use == when comparing known types.
Why: If you know the types in a comparison: If the types are different, the equivalent
of one == would be two (or more!) === (ie, "slower") 

Note: not knowing the types means not fully understaind that code.
So best to refactor so you can know the types.

The usage of === should be reserved for when you do not know the types.


Closures are frequently used in JavaScript for:
object data privacy, in event handlers and callback functions,
and in partial applications, currying, and other functional
programming patterns.

Why understand closures?
Understanding how variables and functions relate to each other is 
critical to understanding what's going on in your code, in both
functional and object oriented programming styles.

Closures are important because they control what is and isn't in scope
in a particular function, along with which variables are shared between
sibling functions in the same containing scope. 

With closures, the inner function will have access to the variables in the outer function
scope, even after the outer function has returned.


Pure functions

A pure function is a function which given the same input, will always produce the same output. 
It produces no side effects.

Pure functions are essential for a variety of purposes, including functional programming,
reliable concurrency, and React+Redux apps. Note: reducers must be pure functions.

If a function were to mutate a property on an object or array parameter that would mutate state
that is accessible outside the function. Pure functions must not mutate external state.

When passing an object to an array to a function, you are passing a reference. You don't
want to mutate the original object or array. Instead, make a copy of the argument. 
e.g. 
const newObject = (value) => Object.assign({}, value); 

Redux

Redux lets you compose reducers rather than deal with the entire app state inside each reducer.

Why compose reducers? You don't have to create a deep clone of the entire app state every time you
want to update just a small part of it. Instead, you can use non-destructive array methods, or 
`Object.assign()` to update a small part of the app state. 

Misc - Functions

Function procedures: 
A function may be called to perform a sequence of steps. The sequence is
known as a procedure, and programming in this style is known as procedural programming. 

Function I/O:
Some functions exist to communicate with other parts of the system, such as the screen, storage,
system logs, or network. 

Program determinism: 
A deterministic algorithm is an algorithm which, given a particular input, will always produce the same
output, with the underlying machine always passing through the same sequence of states. 

Single threaded JS:
A single threaded JS engine does not imply that there is no concurrency. On the contrary, there are many
sources of concurrency in JavaScript. API I/O, event listeners, web workers, iframes, and timeouts can all
introduce indeterminism into your program. 

Concurrency: 
When two tasks can start, run, and complete in overlapping time periods. 

Parallelism:
When tasks literally run at the same time, e.g. on a multi-core processor.  

What is a Promise?

A promise is an object that may produce a single value some time in the future. The value is a resolved value or a reason why it’s not resolved e.g. what error occurred. 

A promise may be in one of three states:
Fulfilled, pending, rejected.

Promise uses can attach callbacks to handle the fulfilled value or the reason for rejection. 

A promise is an object which can be returned synchronously from an asynchronous function.
A promise will be in one of 3 possible states:
Fulfilled: onFulfilled() will be called (e.g., resolve() was called)
Rejected: onRejected() will be called (e.g., reject() was called)
Pending: not yet fulfilled or rejected

A promise is not settled if it’s pending. Once a promise is settled, it can not be resettled.

The ES6 promise constructor takes a function. That function takes two parameters, resolve(), and reject().

You can optionally resolve() or reject() with values, which will be passed to the callback functions attached with .then().
When I reject() with a value, I always pass an Error object. Generally I want two possible resolution states: the normal happy path, or an exception — anything that stops the normal happy path from happening. Passing an Error object makes that explicit.
Promises following the spec must follow a specific set of rules:
A promise or “thenable” is an object that supplies a standard-compliant .then() method.
A pending promise may transition into a fulfilled or rejected state.
A fulfilled or rejected promise is settled, and must not transition into any other state.
Once a promise is settled, it must have a value (which may be undefined). That value must not change.

Every promise must supply a .then() method with the following signature:
promise.then(
 onFulfilled?: Function,
 onRejected?: Function
) => Promise

.then() must return a new promise, promise2

Because .then() always returns a new promise, it’s possible to chain promises with precise control over how and where errors are handled. Promises allow you to mimic normal synchronous code’s try/catch behavior.


Promise Error Handling Example

save()
 .then(handleSuccess)
 .catch(handleError)
;


I recommend ending all promise chains with a .catch().

Promise.race() takes an array (or any iterable) and returns a promise that resolves with the value of the first resolved promise in the iterable, or rejects with the reason of the first promise that rejects.
Promise.all() takes an array (or any iterable) and returns a promise that resolves when all of the promises in the iterable argument have resolved, or rejects with the reason of the first passed promise that rejects.


Scope

JavaScript is parsed/processed before line by line execution occurs. 

