JS fundamentals to functional

Functional programming is a programming style and about verbs
Includes pure functions without side effects. Makes code easier to test and trust.
They can’t affect any other data outside the scope of that function



Object oriented programming is about nouns

Primitive values get passed by value, e.g. string , number, boolean
Non-primitive values get passed by reference, e.g. arrays, objects, functions. It’s important that you don’t mutate your data (unintentionally by modifying the referenced/pointed at value). It is recommended to make copies of your data. 

Objects

Var person = {};		// object literal notation
Person.name = ‘mrs.white’;
Var person = {
	“Name”: “mrs.white”
};

Arrays

Because arrays are objects they can have properties like length and more that are accessed by dot notation.

E.g. perfectly legal to do this

Var person = [];

Person.name = ‘Mrs. White’;

// legal to do this too

Var person = [];

Var plea = “would”;

Person[plea] = “i would”;

// this creates a property “would” with a value “i would”
“Would”: “i would” 	on the person array which is an object.


OR just do this
Person[“plea”] = “i would” 


ES6 Destructuring 
Is a simplified way of defining variables and assigning values from an object or array.

Source 		Target
Const [first, second] = [true, false]

Assignment
[first, second] = [true, false]


Const: can’t reassign to new value

E.g.

Const j = { x: 1 };
J = {}; // won’t work

J.y = 2;
// j = { x: 1, y: 2}; 	will work

E.g.

{first, second} = {first: 0, second: 1}		// the names have to match. First to first , etc 
console.log(first);
// 0 

Omit certain values
Var [a, , b] = [1, 2, 3]
console.log(a, b)
// 1 3 

// Rest syntax looks exactly like spread syntax, but is used for destructuring arrays and objects. In a way, rest syntax is the opposite of spread syntax. Spread syntax "expands" an array into its elements, while rest syntax collects multiple elements and "condenses" them into a single element.
Combine with rest operator (accumulates rest of the values).

Var [a, ...b] = [1, 2, 3]
console.log(a, b)
// 1 [2, 3]

Swap variables easily without temp.
[b, a] = [a, b]

Destructure with objects
Var { user: x } = { user: 5 };
console.log(x)
=> 5


List Transformations - Nested Data Structures

forEach() calls a provided callback function once for each element in an array in ascending order.
[‘a’, ‘b’, ‘c’].forEach(function(value, index, list){ … }); 
callback is invoked with three arguments:
the value of the element
the index of the element
the Array object being traversed

items.forEach(function(item){ copyItems.push(item) })

.map() function
Produces a new array of values by mapping each value in list through a transformation function (iterator)
Each invocation of iterator is called with three arguments: (element, index, list). If list is a JavaScript object, iterator’s arguments will be (value, key, list) 

let numbers = [1, 4, 9] let roots = numbers.map(function(num) { return Math.sqrt(num) }) // roots is now [1, 2, 3] // numbers is still [1, 4, 9]

.filter() 
The filter() method creates a new array with all elements that pass the test implemented by the provided function.

const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);


Functions In-Depth

ES6 arrow functions

() => {} 

var myFunc = (name, number) => {} 

Arrow functions do not have a keyword this that is bound at call time.
Arrow functions do not have a keyword arguments.

Spread operator

var myFunc = (name, ...number) => {} 
// this will gather extra arguments in number and store them
in an array

e.g. myFunc('john', 2, 3)
// number = [2, 3] 


Array-like Objects

Array.from() allows you to create an array from an array-like
or iterable object like a list of arguments. 

const constructArr = function() {
	const arr = Array.from(arguments);
	arr.push('d'); 
	return arr; 
}
constructArr('a', 'b', 'c');


Higher-order functions

In JavaScript, functions are data i.e. they can be passed as 
variables and returned without being invoked.


reduce()

// sum is previous value or accumulated value so far
[1, 2, 3].reduce((sum, currentValue) => {
	return sum + currentValue; 
}, 0);
// 0 is the initial value
// => 6 

Currying
// a functional technique
currying is when you create a function that can be called 
multiple times with different arguments.
currying waits until it receives all the specified arguments
and then it will run the function.

Composing
// a functional technique
when you take two or more functions and combine them

e.g.
f(g(x)) 

In short, compose will accept any number of functions as long as they respect a few simple rules:
- Each function needs to return a result that can be consumed as an argument by the next function in line

- The first function to be called can accept any number of parameters

- The rest of the functions need to accept just one argument

- Functions are applied right to left, so the first function to accept arguments is the right-most function

const consider = (name) => {
	return `I think it could be... ${name}`;
}; 

const exclaim = (statement) => {
	return `${statement.toUpperCase()}!`;
};

const blame = _.compose(consider, exclaim); 

blame('you'); 

=> 'I think it could be... YOU!' 

// what happens is: 
first exclaim() is called with 'you' argument
next the result of exclaim() is passed as an argument to consider()
consider() takes an argument of name which in this case will be 'YOU'
finally the string interpolated result is returned. 




















